def single_lane_road_open(n, div, vmax, v_initial, prob_car_daw, max_iterations):
    ''' Function to generate a road and while cars are generated and move according to a set of rules.
        Inputs:
        n = length of the road
        div = rate of new cars joining the road
        vmax = max speed of the cars
        v_initial = speed of the cars when joining the road
        prob_car_daw = probability of the cars dawdeling 
        max_iterations = number of timesteps
    ''' 
    
    #Create empty road and matrix to store iterations
    road = np.zeros(n)                          
    matrix = np.zeros((max_iterations, n))
    data= np.zeros((max_iterations, 3))
    iterations = 1
    
    while iterations in range(max_iterations):
        
        #Avoid situation where last car doesn't move.
        road[np.size(road)-1]=0     
        
        
        ### Rule 1 ###
        
        # If the velocity v of the car is lower than vmax , and the distance to the next car
        # ahead is larger than v + 1, the speed is increased by one.
        for i in range(np.size(road)-2):
            if road[i]>1:                               
                if sum(road[i+1:i+1+int(road[i])])==0:
                    if road[i]<vmax:
                        road[i]+=1
                        
            
               ### Rule 2 ###
                
               # If a driver at site i sees the next vehicle at site i+j, with j < v, 
               # they reduce speed to j âˆ’1. 
                else:
                    count = i
                    #If there is a car directly in front slow to stationary.
                    if road[count+1]!=0:            
                        road[i]=1
                    else:
                        while road[count+1]<1:
                            #Count is the distance between two cars plus element index.
                            count+=1     
                            #Add 1 back on to account for the start being count +1.
                            road[i]=count-i+1     
                            
               
                ### Rule 3 ###
                
                # The velocity of each moving vehicle is decreased by one with probability p.
                if np.random.randint(1, 100)<=prob_car_daw*100:       
                    if road[i]>1:                                     
                        road[i]-=1
                        
                        
                        
        ### Rule 4 ###
        
        # Each vehicle is advanced by v sites.
        # As the vechicles move forward we have to iterate in reverse as cars move forward.
            
            #Special case where car is stationary.
            elif road[i]==1:                        
                if i<n-1:
                    #If no cars in front, start moving at v=1.
                    if road[i+1]!=1:                
                           road[i]=2
         
        
        for i in range(np.size(road)-1, -1, -1):    
            #for cars that go beyond the road we treat them as no longer existing- open system.
            if i+int(road[i])>n:            
                road[i]=0
                
            else:
                #cars move forward 
                if road[i]>0:                       
                    road= np.insert(road, i+int(road[i]), road[i])       
                    road = np.delete(road, i)

        
        #car generation
        if iterations%div ==1:
            road[0]= v_initial                                                  
        

        #visualisation
        for i in range(np.size(road)):
            if road[i]==0:
                matrix[iterations, i]= 0
            else:
                matrix[iterations, i]= 10
    
        #data collection
        data[iterations, 0]= iterations
        data[iterations, 1]= np.count_nonzero(road)/n
        data[iterations, 2]= round(sum(road)/np.count_nonzero(road) -1, 2)
        
        ### Alternate visualiation tools ###
        
        #print(iterations, road)
        
        #street = []
        #for i in range(np.size(road)):
            #if road[i]==0:
                #street.append(' ')
            #else:
                #street.append(road[i]-1)
       # print(iterations , street)
    
        iterations +=1
 
    fig5 = plt.figure(figsize=(50,50))
    ax5 = fig5.add_subplot(111)
    ax5.imshow (matrix) 
    
    fig, ax1 = plt.subplots()
    ax1.set_ylabel('Timestep')
    ax1.set_ylabel('Car desity')
    ax1.plot(np.arange(0, max_iterations),data[:,1], color="red")
    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
    ax2.set_ylabel('Car Average Speed')
    ax2.plot(np.arange(0, max_iterations),data[:,2], color="blue")
    
